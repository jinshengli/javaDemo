package concurrent.chapter01;


/**
 *  管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发
 *
 *
 *  在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另
 * 一个是同步，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。
 *
 * 管程是如何解决互斥问题的?
 *
 * 将共享变量及其对共享变量的操作统一封装起来,管程 X 将共享变量 queue 这个队列和相关的操作入队 enq()、出队 deq() 都封装起来了；
 * 线程 A 和线程 B 如果想访问共享变量 queue，只能通过调用管程提供的 enq()、deq() 方法来实
 * 现；enq()、deq() 保证互斥性，只允许一个线程进入管程。
 *
 * 管程如何解决线程间的同步问题呢？
 *
 * MESA 模型的主要组成:
 *
 * 在管程模型里，共享变量和对共享变量的操作是被封装起来的,只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入
 * 管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。
 *
 *
 * 管程里还引入了条件变量的概念，而且每个条件变量都对应有一个等待队列。 其实就是解决线程同步问题。
 *
 *
 * notFull.wait();  队列不空条件，当队列不空不满足时，线程进入等待队列，等待到队列不空。
 *
 * notEmpty.await();  队列不满条件，当队列不满不满足时，线程进入【队列不满的等待队列】，等待到队列不满。
 *
 * 入队成功：通知条件变量 队列不空。 notEmpty.notify().
 *
 * 出队成功：队列不满， notFull.notify()。
 *
 * 必须这样调用 wait()：
 *
 *  while( 条件不满足 ){
 *      await()
 *  }
 *
 *  因为在 MESA 模型，在通知T线程完之后，那T线程不会马上执行，会进入入口等待队列中，T线程再次执行时，
 *  可能 就不满足条件变量了。
 *
 *  可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量
 *
 */


public class WhatMESA {




}
